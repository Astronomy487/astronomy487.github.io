<!DOCTYPE html>
<html>
<head>
	<style>
		body {
			width: 64rem;
			margin: 8rem auto;
			background: black;
			color: white;
		}
		canvas {
			border-radius: 100%;
		}
		canvas:hover {
			background: radial-gradient(circle at center, #444, #000 70%);
		}
		button {
			font-family: inherit;
			font-size: inherit;
			border: solid 1px white;
			padding: 0.5rem 1rem;
			background: black;
			color: inherit;
			margin-top: 1rem;
			cursor: pointer;
		}
		button:hover {
			color: black;
			background: white;
		}
	</style>
</head>
<body>
	<h1>All the graphs, just in case you ever needed to know all the graphs</h1>
	<input type="checkbox" id="firstConnectionCodeButton" onchange="firstConnectionCode=this.checked?1:0;reset();"><label for="firstConnectionCodeButton" style="margin-left: 0.5rem;">Require graphs be connected</label>
	<hr>
	<div id="output"></div>
	<button onclick="clearInterval(creationDemand); creationDemand = setInterval(process, 1); setTimeout(function(){clearInterval(creationDemand)},5000)">Demand more</button>
	<script>
		let creationDemand;
		
		let firstConnectionCode = 0;
		
		function isIsomorphic(adj1, adj2) {
		  let degreeMultiset1 = adj1.map(x => x.reduce((a,b)=>a+b,0)).sort();
		  let degreeMultiset2 = adj2.map(x => x.reduce((a,b)=>a+b,0)).sort();
		  if (degreeMultiset1.join(" ") != degreeMultiset2.join(" ")) return false;
		  
		  let n = adj1.length;

		  // Helper function to generate all permutations of an array
		  function permutations(arr) {
			if (arr.length === 0) {
			  return [[]];
			}

			const result = [];
			for (let i = 0; i < arr.length; i++) {
			  const el = arr[i];
			  const rest = arr.slice(0, i).concat(arr.slice(i + 1));
			  const perms = permutations(rest);
			  for (const perm of perms) {
				result.push([el].concat(perm));
			  }
			}
			return result;
		  }

		  // Generate all possible permutations of vertices
		  const vertexPermutations = permutations(Array.from({ length: adj1.length }, (_, i) => i));

		  // Check if any permutation results in the same adjacency matrix
		  for (const permutation of vertexPermutations) {
			const permutedAdj = [];
			for (let i = 0; i < n; i++) {
			  permutedAdj[i] = [];
			  for (let j = 0; j < n; j++) {
				permutedAdj[i][j] = adj1[permutation[i]][permutation[j]];
			  }
			}

			if (JSON.stringify(permutedAdj) === JSON.stringify(adj2)) {
			  return true;
			}
		  }

		  return false;
		}
		
		let isomorphicAdjs, extensionQueue;
		firstConnectionCodeButton.checked = true;
		firstConnectionCodeButton.onchange(); //will perform reset
		
		function reset() {
			clearInterval(creationDemand);
			while (output.firstChild) output.firstChild.remove();
			extensionQueue = [];
			isomorphicAdjs = [
				[ [] ],
				[ [[0]] ]
			];
			document.querySelector("button").onclick();
		}
		
		function process() {
			if (!extensionQueue.length) {
				let n = isomorphicAdjs.length;
				isomorphicAdjs.push([])
				output.appendChild(document.createElement("h2")).innerText = "Order " + n;
				for (let baseAdj of isomorphicAdjs[n-1]) {
					for (let connectionCode = firstConnectionCode; connectionCode < 1<<(n-1); connectionCode++) {
						extensionQueue.push([baseAdj, connectionCode]);
					}
				}
			}
			let [newMatrix, connectionCode] = extensionQueue.shift();
			newMatrix = newMatrix.map(x => x.slice());
			let will = new Array(newMatrix.length).fill(0).map((_,i)=>i).map(pow => connectionCode&(1<<pow)?1:0);
			newMatrix.push(will);
			for (let i = 0; i < newMatrix.length-1; i++) newMatrix[i].push(will[i]);
			newMatrix[newMatrix.length-1].push(0);
			
			for (let e of isomorphicAdjs[isomorphicAdjs.length-1]) if (isIsomorphic(e, newMatrix)) return process();
			draw(newMatrix);
			isomorphicAdjs[isomorphicAdjs.length-1].push(newMatrix);
		}
		
		function xpos(l) {
			return 75 + 55 * Math.sin(l*2*Math.PI);
		}
		function ypos(l) {
			return 75 - 55 * Math.cos(l*2*Math.PI);
		}
		
		let colorChoices = ["gray","#f44","#ff0","#4f4","#0ff","#44f"];
		
		function draw(mat) {
			let n = mat.length;
			let canvas = output.appendChild(document.createElement("canvas"));
			canvas.height = canvas.width = 150;
			let ctx = canvas.getContext("2d");
			ctx.lineWidth = 2;
			ctx.strokeStyle = "white";
			for (let i = 0; i < n; i++) for (let j = i+1; j < n; j++) if (mat[i][j]) {
				ctx.beginPath();
				ctx.moveTo(xpos(i/n), ypos(i/n));
				ctx.lineTo(xpos(j/n), ypos(j/n));
				ctx.stroke();
			}
			ctx.strokeStyle = "black";
			for (let i = 0; i < n; i++) {
				ctx.beginPath();
				ctx.arc(xpos(i/n), ypos(i/n), 7, 0, 2 * Math.PI);
				let order = mat[i].reduce((x,y)=>x+y,0);
				ctx.fillStyle = "white";
				//ctx.fillStyle = order in colorChoices ? colorChoices[order] : "#f0f";
				
				ctx.fill();
				ctx.stroke();
			}
		}
	</script>
</body>
</html>