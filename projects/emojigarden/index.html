<!DOCTYPE html>
<html>
<head>
  <title>emoji garden</title>
  <meta charset="UTF-8">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
    
    * {
      font-family: 'Noto Color Emoji', 'Inter', sans-serif;
      user-select: none;
      font-weight: normal;
    }
    
    body {
      margin: 0;
      position: fixed;
      left: 0;
      top: 0;
    }
    
    table {
      position: fixed;
      border-collapse: collapse;
      border: solid 1px black;
      transition: 0.1s box-shadow, 0.1s transform;
      box-shadow: 0.25rem 0.25rem black;
      background-color: #FFFFFF20;
      backdrop-filter: blur(0.5rem);
    }
    
    table[dragging="true"] {
      box-shadow: 0.5rem 0.5rem black;
      transform: translate(-0.25rem, -0.25rem);
    }
    
    th {
      background-color: white;
      padding: 0.25rem;
      height: 0.5rem;
      text-align: center;
      color: white;
      font-weight: normal;
      border-bottom: solid 1px black;
      cursor: move;
    }
    
    td {
      width: 4rem;
      height: 4rem;
      font-size: 3rem;
      line-height: 4rem;
      text-align: center;
      transition: 0.1s;
      border-radius: 4rem;
    }
    
    td:empty {opacity: 0;}
    
    td[can_action="true"]:hover, td[dropdowned="true"] {
      background-color: #FFFFFF60;
      cursor: pointer;
    }
    
    /* action particles */
    
    @keyframes action_particle_animation {
      from {opacity: 0; transform: inherit;}
      25% {opacity: 1; transform: translateY(-1rem);}
      to {opacity: 0; transform: translateY(-0.5rem);}
    }
    i {
      font-size: 2rem;
      font-style: normal;
      position: fixed;
      animation: 1s action_particle_animation ease-in-out;
      z-index: 99999;
      pointer-events: none;
    }
    
    nav {
      z-index: 99999;
      font-size: 1.25rem;
      position: fixed;
      left: 0;
      bottom: 0;
      padding: 2rem;
      font-family: 'Material Symbols Outlined';
      opacity: 0.25;
      transition: 0.1s opacity;
    }
    
    nav:hover {
      opacity: 1;
    }
    
    button {
      display: block;
      margin: 0;
      cursor: pointer;
      background-color: #eee;
      border: solid 1px black;
      color: black;
      font-size: 1rem;
      padding: 0.5rem 1rem;
    }
    
    button:hover, button:focus {
      background-color: white;
    }
    
    @keyframes enter_below {
      from {opacity: 0; transform: translateY(1rem);}
    }
    
    @keyframes exit_below {
      to {opacity: 0; transform: translateY(1rem);}
    }
    
    aside {
      font-size: 1.5rem;
      position: fixed;
      z-index: 9999;
      animation: 0.25s enter_below;
    }
    
    aside a:not(:first-child) {
      margin-left: 0.5rem;
    }
    
    aside a {
      border: solid 1px black;
      background-color: #eee;
      cursor: pointer;
      transition: background-color 0.1s;
      border-radius: 4rem;
      padding: 1rem;
    }
    
    aside a:hover {
      background-color: white;
    }
    
    article {
      display: block;
      background-color: white;
      border: solid 1px black;
      padding: 1rem;
      width: 16rem;
      position: fixed;
      left: 2rem;
      bottom: 2rem;
      z-index: 9999999;
    }
    
    article input[type="color"] {
      padding: 0;
      border: none;
      width: 2rem;
      height: 2rem;
      vertical-align: middle;
    }
    
    article input {
      height: 1rem;
      font-size: 1rem;
      padding: 0.5rem;
      width: 10rem;
      vertical-align: middle;
      background-color: white;
      border: none;
    }
    
    article input:focus {
      outline: none;
      background-color: #eee;
    }
    
    article button {
      margin-top: 1rem;
      width: 16rem;
    }
  </style>
</head>
<body onbeforeunload="save_garden();">
  <nav>
    <button onclick="document.querySelector('article').style.display = 'block';" style="border-radius: 4rem;">i</button>
  </nav>
  <article style="display: none;">
    <input type="color" id="input_bg" oninput="file.bg = this.value; document.body.style.backgroundColor = this.value;">
    <input type="text" id="input_title" oninput="file.title = this.value; document.querySelector('title').innerText = this.value ? this.value : '-';">
    <button onclick="document.querySelector('article').style.display = 'none';" style="border-width: 0 0 1px 1px; display: inline-block; padding: 0.5rem 0; width: 2.5rem; position: absolute; top: -1rem; right: 0; text-align: center;">×</button>
    <button onclick="ask_delete_garden_permanently();">Reset garden (permanent)</button>
  </article>
  <div id="field"></div> <!-- all those field rectangles -->
  <!--<div style="font-size: 3rem; width: 24rem;" id="avatars">👩‍🌾👩🏿‍🌾👩🏾‍🌾👩🏽‍🌾👩🏼‍🌾👩🏻‍🌾<br>🧑‍🌾🧑🏿‍🌾🧑🏾‍🌾🧑🏽‍🌾🧑🏼‍🌾🧑🏻‍🌾<br>👨‍🌾👨🏿‍🌾👨🏾‍🌾👨🏽‍🌾👨🏼‍🌾👨🏻‍🌾</div>-->
  <script>
    /*
    todo list
    - do field TYPES. 🦑🐟🐡🐠🦈<== these beasts only exist in the ocean
    - make Info/Settings page look good, include user text to put in <title>
      things that are in settings:
        - bg color
        - reset your save
      info page is regrettable because i want as little text as possible
    - design uncertainty: how should you acquire new plots / plants / animals? i dont want this to be an economics game
    - in general What tiles should exist
        currently have 🌾🌽🎃  🐑🐕  🌴🥥  🌷🌸🌹🌺🌼🌻🏵
    */
    
    let file = {}; //The Save File Of All Your Info. it's constantly saved into localstorage. it includes elements
    
    function save_garden() {
      file.last_saved = Date.now();
      //make copy of file save, but remove all table_element td_element (generated)
      let file_save = JSON.parse(JSON.stringify(file));
      for (p of file_save.field) {
        delete file_save.table_element;
        for (r of p.cells) for (c of r) if (c) {
          delete c.td_element;
        }
      }
      localStorage.setItem("garden_data", JSON.stringify(file_save));
    }
    setInterval(save_garden, 1000*15);
    
    function delete_garden_permanently() {
      file = {};
      localStorage.removeItem("garden_data");
      location.reload();
    }
    function ask_delete_garden_permanently() {
      let notice = document.createElement("article");
      notice.style.left = "50%";
      notice.style.top = "50%";
      notice.style.transform = "translate(-50%, -50%)";
      let par = document.createElement("p");
      notice.appendChild(par);
      par.innerText = "Your garden will be permanently reset to the default state. None of your posessions or friends will survive.";
      let button = document.createElement("button");
      button.onclick = delete_garden_permanently;
      button.innerText = "Seriously, delete my garden";
      notice.appendChild(button);
      document.body.appendChild(notice);
    }
    
    /* field = the things you have out in the world that have some position. every object will include:
      - x y z
      - table_element
      - plot_type       "land", "water". invisible. determines what kinds of objects can be here //not yet cared about
      - cells[]
      
      PlotCell
      - next_ready      timestamp when this cell will next be ready
      - display         visually what to draw here 🌾
      - td_element
      - action[]        what can we do once ready
        - display       🥛Milk
        - cooldown      1000*8
        - gain[]        what does this change of our resources
          - resource    🥛
          - amt         +1
        - special       what do after this action? "delete"? "spread"?
    */
    
    try {
      file = localStorage.getItem("garden_data");
      file = JSON.parse(file);
      if (file.field == undefined) throw "";
    } catch (exception) {
      file = {};
      file.last_saved = Date.now();
      file.field = [];
      file.bg = "#008080";
      file.title = "my emoji garden";
      file.field[0] = {
        x: 0, y: 0, z: 1,
        plot_type: "land",
        cells: new_field("🌾 🌾 🐑 🌾 🌾/🌾 🐑 🌾 🌾 🌾/🌾 🌾 🌾 🐑 🐕")
      };
      file.field[1] = {
        x: 200, y: 300, z: 1,
        plot_type: "land",
        cells: new_field("🌾 🌾 🌾/🌽 🌽 🌽/🎃 🎃 🎃")
      };
      file.field[2] = {
        x: -100, y: 300, z: 1,
        plot_type: "land",
        cells: new_field("# # #/# 🏵 #/# # #")
      };
      file.field[3] = {
        x: -300, y: 100, z: 1,
        plot_type: "land",
        cells: new_field("# 🌴 #/# 🥥 #")
      };
    }
    
    let yoinked_plot = null; //null, or plot element
    let yoinked_origin = null; //mouse coords
    let global_scroll = [0, 0]; //added to fixed left right things
    let global_scroll_origin = null;
    
    //wait, let's normalize the x y positions of all plots
    let sum_x = 0; let sum_y = 0;
    for (p of file.field) {
      sum_x += p.x + p.cells[0].length*32;
      sum_y += p.y + p.cells.length*32 + 12;
    }
    sum_x /= file.field.length;
    sum_y /= file.field.length;
    sum_x -= window.innerWidth/2;
    sum_y -= window.innerHeight/2;
    for (p of file.field) {
      p.x -= sum_x;
      p.y -= sum_y;
    }
    
    //define all cell actions here
    let actions = {};
    
    actions["🐑"] = [{
      display: "💙",
      cooldown: 5000,
      gain: []
    }];
    
    actions["🥥"] = [{
      display: "🧺",
      cooldown: 1000,
      gain: [],
      special: "delete"
    }];
    
    actions["🏵"] = [{
      display: "🌱",
      cooldown: 1,
      gain: [],
      special: "spread"
    },{
      display: "🗑️",
      cooldown: 10,
      gain: [],
      special: "delete"
    }];
    for (f of ["🌷","🌹","🌸","🌺","🌼","🌻"]) actions[f] = actions["🏵"];
    
    actions["🌾"] = [{display:"🧺",cooldown:1000*60*1,gain:[]}]
    actions["🌽"] = [{display:"🧺",cooldown:1000*60*2,gain:[]}]
    actions["🎃"] = [{display:"🧺",cooldown:1000*60*3,gain:[]}]
    
    actions["🐕"] = [];
    actions["🌴"] = [];
    
    function new_cell(emoji) {
      return {
        next_ready: Date.now(),
        display: emoji
      };
    }
    function new_field(arr) {
      let cells = arr.split("/");
      for (let y = 0; y < cells.length; y++) {  
        cells[y] = cells[y].split(" ");
        for (let x = 0; x < cells[y].length; x++) {
          cells[y][x] = cells[y][x] == "#" ? null : new_cell(cells[y][x]);
        }
      }
      return cells;
    }
    
    
    let dropdown_open = null;
    
    //apply cellular automata for however long we've been gone
    for (p of file.field) do_simulation_on_plot(p, Math.floor(Date.now() - file.last_saved)/500);
    file.last_saved = Date.now();
    
    //construct html for all the fields. when fields added / removed, this is re called
    construct_html();
    function construct_html() {
      while (document.getElementById("field").firstChild) document.getElementById("field").firstChild.remove();
      for (plot of file.field) {
        construct_plot_html(plot);
      }
    }
    
    let z_counter = 0; //ever increasing, highest z count
    for (plot of file.field) z_counter = Math.max(z_counter, plot.z);
    function z_count() {z_counter++; return z_counter;}
    
    function construct_plot_html(plot) {
      if (plot == yoinked_plot) return;
      if (plot.table_element) try{plot.table_element.remove()}catch(e){};
      let table = document.createElement("table");
      plot.table_element = table;
      table.style.left = plot.x + "px";
      table.style.top = plot.y + "px";
      table.style.zIndex = plot.z;
      table.onmousedown = function(event){event.stopPropagation();}
      let grabber_tr = document.createElement("tr");
      let grabber_th = document.createElement("th");
      grabber_th.setAttribute("colspan", plot.cells[0].length);
      table.appendChild(grabber_tr);
      grabber_tr.appendChild(grabber_th);
      grabber_th.onmousedown = function(event) {
        for (plot of file.field) if (plot.table_element == table) {
          yoinked_plot = plot;
          yoinked_plot.z = z_count();
          yoinked_plot.table_element.style.zIndex = yoinked_plot.z;
          yoinked_plot.table_element.setAttribute("dragging", "true");
          if (dropdown_open) {
            close_dropdown();
          }
        }
        yoinked_origin = [event.pageX, event.pageY];
      }
      for (row of plot.cells) {
        let tr = document.createElement("tr");
        for (cell of row) {
          let td = document.createElement("td");
          tr.appendChild(td);
          if (cell == null) continue;
          cell.td_element = td;
          td.innerText = cell.display;
          update_action_indicator(cell);
          td.onmousedown = function(event) {
            for (plot of file.field) for (row of plot.cells) for (cell of row) if (cell) if (cell.td_element == this) {
              if (event.button == 0)
              act_on_cell(plot, cell);
              else
              ask_act_on_cell(plot, cell);
            }
          }
          td.setAttribute("oncontextmenu", "return false;"); //people online call this immoral but i want to stop right clicking from doing that
        }
        table.appendChild(tr);
      }
      document.getElementById("field").appendChild(table);
      return table;
    }
    
    document.onmouseup = function() {
      if (yoinked_plot) {
        yoinked_plot.x = yoinked_plot.x + event.pageX - yoinked_origin[0];
        yoinked_plot.y = yoinked_plot.y + event.pageY - yoinked_origin[1];
        yoinked_plot.table_element.style.left = yoinked_plot.x + "px";
        yoinked_plot.table_element.style.top = yoinked_plot.y + "px";
        yoinked_plot.table_element.setAttribute("dragging", "false");
        yoinked_plot = null;
        yoinked_origin = null;
      }
      if (global_scroll_origin) {
        global_scroll_origin = null;
      }
    }
    
    document.onmousemove = function(event) {
      if (yoinked_plot) {
        yoinked_plot.table_element.style.left = yoinked_plot.x + event.pageX - yoinked_origin[0] + "px";
        yoinked_plot.table_element.style.top = yoinked_plot.y + event.pageY - yoinked_origin[1] + "px";
      }
      if (global_scroll_origin) {
        for (p of file.field) {
          p.x += event.pageX - global_scroll_origin[0];
          p.y += event.pageY - global_scroll_origin[1];
        }
        global_scroll_origin = [event.pageX, event.pageY];
        update_plot_positions();
        close_dropdown();
      }
    }
    
    //overall page scrolling
    document.onmousedown = function(event) {
      if (global_scroll_origin) return;
      if (dropdown_open) {
        //close_dropdown();
      }
      global_scroll_origin = [event.pageX, event.pageY];
    }
    
    //TODO: find more scenarios where essentially a plot's position has to be fixed up, based on file.field[i].x,.y
    function update_plot_positions() {
      for (p of file.field) {
        p.table_element.style.left = p.x + "px";
        p.table_element.style.top = p.y + "px";
      }
    }
    
    //visually update cells that are ready to have actions done
    setInterval(function(){
      for (plot of file.field) for (row of plot.cells) for (cell of row) if (cell) {
        update_action_indicator(cell);
      }
    }, 100);
    function update_action_indicator(cell) {
      cell.td_element.setAttribute("can_action", (Date.now() - cell.next_ready > 0) && actions[cell.display].length > 0);
      if (["🌾","🌽","🎃"].includes(cell.display)) cell.td_element.innerText = (Date.now() - cell.next_ready > 0) ? cell.display : "🌱";
    }
    
    //for every hour, do 7200 iterations of sim. max 172800 iterations (= 48 hours)
    setInterval(function(){
      for (plot of file.field) /*if (yoinked_plot != plot)*/ do_simulation_on_plot(plot, 1);
    }, 500); //2 steps per second
    
    document.querySelector("#input_bg").value = file.bg;
    document.body.style.backgroundColor = file.bg;
    document.querySelector("#input_title").value = file.title;
    document.querySelector("title").innerText = file.title ? file.title : '-';
    
    //update each plot on file.field N number of times, and if changes made, construct plot html
    function do_simulation_on_plot(plot, n) {
      if (n > 345600) n = 345600;
      let previous_plot = JSON.stringify(plot);
      let this_plot_contains_dropdowned = (dropdown_open!=null) && plot.table_element.contains(dropdown_open.td_element);
      for (let iterations = 0; iterations < n; iterations++) {
        //get all (x,y) coords in RANDOM ORDER so theres no left-wandering bias!
        let pairs = [];
        for (let y = 0; y < plot.cells.length; y++) for (let x = 0; x < plot.cells[y].length; x++) pairs.push([x,y]);
        pairs.sort((a,b)=>chance(50)?1:-1);
        for (pair of pairs) {
          let x = pair[0]; let y = pair[1]
          if (!plot.cells[y][x]) continue;
          //plot.cells[y][x] is a PlotCell
          let this_cell = plot.cells[y][x]
          //if animal, wander around maybe
          determine_what_to_do:
          if ((["🐑"].includes(this_cell.display) && chance(4)) || (["🐕"].includes(this_cell.display)&&chance(30))) { //wander behavior
            let offsets = [[-1,0],[1,0],[0,-1],[0,1]].sort((a,b)=>chance(50));
            for (offset of offsets) try {
              if (y+offset[0] < 0) continue;
              if (x+offset[1] < 0) continue;
              let neighbor = plot.cells[y+offset[0]][x+offset[1]];
              if (neighbor === null) {
                plot.cells[y+offset[0]][x+offset[1]] = this_cell;
                plot.cells[y][x] = null;
                break determine_what_to_do; //break outside offsets loop.
              } else if (neighbor.display == "🌾") {
                plot.cells[y+offset[0]][x+offset[1]] = null;
                break determine_what_to_do;
              }
            } catch(e) {}
          } else if (["🌷","🌹","🌸","🌺","🌼","🌻","🏵"].includes(this_cell.display) && chance(0.0001)) { //flowers spread
            let offsets = [[-1,0],[1,0],[0,-1],[0,1]].sort((a,b)=>chance(50));
            for (offset of offsets) try {
              if (y+offset[0] < 0) continue;
              if (x+offset[1] < 0) continue;
              let neighbor = plot.cells[y+offset[0]][x+offset[1]];
              if (neighbor === null) {
                plot.cells[y+offset[0]][x+offset[1]] = JSON.parse(JSON.stringify(this_cell));
              }
            } catch(e) {}
          } else if (this_cell.display == "🌴" && chance(1)) { //
            let offsets = [,[1,0],[0,-1],[0,1]].sort((a,b)=>chance(50));
            for (offset of offsets) try {
              if (y+offset[0] < 0) continue;
              if (x+offset[1] < 0) continue;
              let neighbor = plot.cells[y+offset[0]][x+offset[1]];
              if (neighbor === null) {
                plot.cells[y+offset[0]][x+offset[1]] = new_cell("🥥");
                break determine_what_to_do; //break outside offsets loop.
              }
            } catch(e) {}
            
          }
        }
      }
      if (previous_plot != JSON.stringify(plot)) {
        construct_plot_html(plot);
        if (this_plot_contains_dropdowned) close_dropdown();
      }
    }
    
    let preffered_actions = {}; //users pick what actions
    function act_on_cell(plot, cell, aside) {
      if (!cell) return;
      if (cell.next_ready > Date.now()) return;
      let these_actions = actions[cell.display];
      let action_number;
      if (these_actions.length <= 1) {
        action_number = 0;
      } else if (preffered_actions[cell.display] != undefined) { //several actions, but one is preffered
        action_number = preffered_actions[cell.display];
      } else { //we just need to ask you
        ask_act_on_cell(plot, cell);
        return;
      }
      if (dropdown_open) close_dropdown();
      let this_action = these_actions[action_number];
      if (!these_actions[action_number]) return;
      //carry through with action
      cell.next_ready = Date.now() + this_action.cooldown;
      special_actions:
      if (this_action.special == "delete") {
        for (row of plot.cells) for (let c = 0; c < row.length; c++) {
          if (row[c] == cell) row[c] = null;
        }
      } else if (this_action.special == "spread") {
        for (let y = 0; y < plot.cells.length; y++) for (let x = 0; x < plot.cells[y].length; x++) if (plot.cells[y][x] == cell) {
          let offsets = [[-1,0],[1,0],[0,-1],[0,1]].sort((a,b)=>chance(50));
          for (offset of offsets) try {
            if (y+offset[0] < 0) continue;
            if (x+offset[1] < 0) continue;
            let neighbor = plot.cells[y+offset[0]][x+offset[1]];
            if (neighbor === null) {
              plot.cells[y+offset[0]][x+offset[1]] = JSON.parse(JSON.stringify(cell));
              break special_actions;
            }
          } catch(e) {}
        }
      }
      let action_particle_element = document.createElement("i");
      action_particle_element.innerText = this_action.display;
      action_particle_element.style.left = cell.td_element.getBoundingClientRect().left+6+Math.random()*12 + "px";
      action_particle_element.style.top = cell.td_element.getBoundingClientRect().top + "px";
      document.body.appendChild(action_particle_element);
      setTimeout(function(action_particle_element){
        action_particle_element.remove();
      }, 1000, action_particle_element);
      construct_plot_html(plot);
    }
    
    function ask_act_on_cell(plot, cell) {
      if (dropdown_open) return;
      cell.td_element.setAttribute("dropdowned", "true");
      //there are several options
      let rectangle = cell.td_element.getBoundingClientRect();
      //make and show the dropdown
      let aside = document.createElement("aside");
      aside.style.left = rectangle.right+1.25+"px";
      aside.style.top = rectangle.top+18.875+"px";
      dropdown_open = {aside:aside, td_element:cell.td_element};
      for (let i = 0; i < actions[cell.display].length; i++) {
        let a = document.createElement("a");
        a.innerText = actions[cell.display][i].display;
        a.onclick = function() {
          preffered_actions[cell.display] = i;
          act_on_cell(plot, cell, aside);
          close_dropdown();
        }
        aside.appendChild(a);
      }
      document.body.appendChild(aside);
    }
    function close_dropdown() {
      if (!dropdown_open) return;
      dropdown_open.td_element.setAttribute("dropdowned", "false");
      let aside = dropdown_open.aside;
      dropdown_open.aside.style.animation = "0.25s exit_below";
      dropdown_open = null;
      setTimeout(function(){
        document.querySelector("aside").remove();
      }, 240);
    }
    
    function chance(percent) {return Math.random() < percent*0.01;}
    
    function human_readable_time(ms) {
      if (ms < 60*1000) return Math.floor(ms/1000)+"s";
      if (ms < 60*60*1000) return Math.floor(ms/1000/60)+"m";
      if (ms < 24*60*60*1000) return Math.floor(ms/1000/60/60)+"h";
      if (ms < Number.POSITIVE_INFINITY) return Math.floor(ms/1000/60/60/24)+"d";
      return "∞";
    }
    
    console.log("done loadin");
  </script>
</body>
</html>