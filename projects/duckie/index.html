<!DOCTYPE html>
<html>
<head>
  <link rel="icon" href="art/duckie.png">
  <title>duckie</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible&display=swap');
    
    body {
      background-color: #472D3C;
      color: #CFC6B8;
      margin: 0;
      user-select: none;
      font-family: 'Atkinson Hyperlegible';
      overflow: hidden;
      font-size: 0;
    }
    
    #display {
      border-collapse: collapse;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }
    
    @keyframes td_enter {from {
      opacity: 0;
      transform: translateY(0.25rem);
    }}
    @keyframes td_exit {to {
      opacity: 0;
      transform: translateY(0.25rem);
    }}
    #display td {
      width: 1rem;
      height: 1rem;
      background-size: cover;
      image-rendering: pixelated;
      animation: 1s td_enter;
      z-index: 1;
      width: 4rem;
      height: 4rem;
    }
    
    #display td:hover cancel {
      background-color: #4F3242;
    }
    
    @keyframes td_img_enter {from {
      transform: translateY(0.125rem);
    }}
    #display td img {
      width: 1rem;
      height: 1rem;
      display: block;
      animation: 1s td_img_enter;
      z-index: 2;
      pointer-events: none;
      width: 4rem;
      height: 4rem;
    }
    
    #color_cover {
      position: fixed;
      width: 100vw;
      height: 100vh;
      background-color: #88888800;
      transition: 1s background-color;
      z-index: 3;
      mix-blend-mode: overlay;
      pointer-events: none;
    }
    
    @keyframes title_enter {from {
      opacity: 0;
      transform: translate(-50%, calc(-50% + 3rem));
    }}
    @keyframes title_exit {to {
      opacity: 0;
      transform: translate(-50%, calc(-50% + 3rem));
    }}
    #title {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, calc(-50% + 2rem));
      font-weight: normal;
      font-size: 2rem;
      margin: 0;
      cursor: pointer;
      padding: 100rem;
      animation: 1s title_enter;
    }
    #title img {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, calc(-50% - 2rem));
      height: 4rem;
      width: 4rem;
      image-rendering: pixelated;
    }
    
    #crystal_shards {
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
    }
    #crystal_shards img {
      image-rendering: pixelated;
      width: 4rem;
      height: 4rem;
      margin: 0;
    }
    
    /* fanfare */
    h2 {
      font-size: 2rem;
      font-weight: normal;
      margin: 0;
      position: fixed;
      left: 50%;
      top: 1rem;
      transform: translateX(-50%);
      background-color: black;
      border: solid 0.25rem #7A444A;
      background-color: inherit;
      width: 24rem;
      padding: 1rem;
    }
    h2 img {
      image-rendering: pixelated;
      width: 4rem;
      height: 4rem;
      margin: 0;
      display: inline-block;
      vertical-align: middle;
    }
  </style>
</head>
<body>
  <table id="display"></table>
  <h1 id="title" onclick="start_game();"><img src="art/duckie.png"></h1>
  <div id="color_cover"></div>
  <div id="crystal_shards"></div>
  <pre id="all_level_info" style="display: none;">

@conwaytest
region:start
data_bottom: ..................|........ss........|......ssssss......|....ssssssssss....|..ssswwwwwwwwsss..|.sssswswwwwswssss.|..ssswwwwwwwwsss..|....ssssssssss....|......ssssss......|........ss........|..................
data_top: ..................|..................|..................|..................|..................|..................|..................|..................|..................|..................|..................

@playground
region: sepia
data_bottom:wwss..)(&!@#...|wsss...........|sssw...........|ssww.112233....|............+{-|............[=]|.,.........._};|.,...i......QWE|.,...ii.....ASD|.....iii....ZXC
data_top:...............|.............$.|...............|.....1.2.3.....|...............|......1.2.3....|..{`...........|..]?......~....|..[............|...............

@origin
region:start
exit_right: puzzle0
data_bottom:..,...,..,.,...|.+{-,...,,.....|+==={-..,..,,,.|[====].,....,..|_====]...,,...,|.[===;...,....,|._==],,.....,.*|,.[=],.....,...|.._=={{{{{{{{{{|.,._}}}}}}}}}}}
data_top:......][..{{...|.....{..[]..]..|.............[.|...`.........].|.........{....{|.........[]...[|.......~..{....|.........[...{[|{..............|...............

@origin backtrack
region:start
exit_right: puzzle0
data_bottom:..,...,..,.,...|.+{-,...,,.....|+==={-..,..,,,.|[====].,....,..|_====]...,,...,|.[===;...,....,|._==],,1....,.*|,.[=],.....,...|.._=={{{{{{{{{{|.,._}}}}}}}}}}}
data_top:......][..{{...|.....{..[]..]..|.............[.|...`.........].|.........{....{|.........[]...[|.......$..{....|.........[...{[|{..............|...............

@puzzle0
region:start
exit_left: origin backtrack
exit_right: puzzle1
data_bottom:.,...,..[|,...,.,.[|..1,...,_|*,..,.!.*|{{{{{{{{{|}}}}}}}}}
data_top:   .[{{]]{[.|][....{..|{...1..[.|.........|.........|.........

@puzzle1
region: start
exit_left: puzzle0
exit_top: puzzle2
data_bottom:=]*....,.[]|=],..,.,.[]|=;!.,....[]|],...1,..[]|;..,.,.,.[]|*..,1...+=]|{{{{{{{{==]|}}}}}}}}}};
data_top:   ...{..][...|...{]]..[..|...[...1{..|...{.......|..1[.].....|.....{[....|...........|...........

@puzzle2
region: start
exit_top: puzzle3
exit_bottom: puzzle1
data_bottom:[=],*[===]|[=].,[===]|[=]!._}==]|[=;,..,_=]|[]1.,...[]|[].,....[]|[]1..,..[=|[].,,..,_}|[]..+-.,..|[={{==-*..
data_top:   ...{......|..........|....[.....|..........|...][.1...|.....1....|...[{.....|..........|........{.|........[]

@puzzle3
region: start
exit_bottom: puzzle2
exit_left: puzzle4
data_bottom: ..,,....,|,,..,...,|..,,..1.,|*,!...1,.|{-,..,1,.|=].,.+{{{|==-.*[===
data_top:    ]..][{...|..[...].[|{]{..1.{.|....11.].|..]{...{[|..[].....|...{.....

@puzzle4
region: start
exit_right: puzzle3
exit_top: puzzle5
data_bottom:....,*.|,,.1..,|....,!.|.,,1.,.|{{-,...|==]1,.*|==].+{{
data_top:.[{]{.{|]...[.]|{...].]|].111.{|......[|.`.....|...[...

@puzzle5
region: dungeon
exit_bottom: puzzle4
exit_right: playground
data_bottom:cXXXXXXz|D......A|D...3..A|D......A|D......Z|D..&.#.*|D*QWWWWW
data_top:........|........|...3....|....?...|..[{][{.|........|........

  </pre>
  <script>
  /*
  BOTTOM LAYER
  untraversable
  - wall
  - rivers
  - conversational
  - map edges
  - trees
  traversable
  - plain old floor (+ decorated plain old floor)
  - river + bridge

  TOP LAYER
  - player
  - enemy
  - box
  
  
  
  
  special behaviors to be encoded
  - signs / npcs that can initiate dialogue
  - doors that initiate scene transition (how can these correspond to initial player locations?)
  
  
  */
  
  let room_bottom = null; //2d array for currently loaded room. each cell is {bool traversible, int goal(0=nogoal)}
  let room_top = null; //2d array for entities that can move
  let room_bottom_elements = null;
  let room_top_elements = null;
  let width = null;
  let height = null;
  let active_exits = [];
  let input_disabled = false;
  let loaded_room_label = null;
  let crystal_shard_collected = {}; //list of rooms with crystal shard. eg intro1:true
  
  let display = document.querySelector("table#display");
  
  let all_rooms = {}; //dictionary for rooms. each room is {data_top (using chars), data_bottom (using chars)}
  let region_info = {
    // #2B6AC5 blue sombercore
    start: {color: "#9B7E57"}, //introductory sokoban. simple puzzles that use normal elements
    dungeon: {color: "#2B6AC5"},
    sepia: {color: "#6F9986"}
  };
  function open_room(label, coming_from = "left") {
    let room_data = all_rooms[label];
    if (!room_data) return;
    //read data
    document.querySelector("#color_cover").style.backgroundColor = region_info[room_data.region].color;
    //document.querySelector("title").innerText = "duckie : " + label;
    //document.querySelector("#color_cover").style.backgroundColor = "#"+Math.floor(Math.random()*16777215).toString(16); console.log(document.querySelector("#color_cover").style.backgroundColor);
    if (room_data.room_bottom && room_data.room_top) { //if this room has already been saved
      room_bottom = room_data.room_bottom;
      room_top = room_data.room_top;
    } else { //room has no .room_bottom/top attributes, so this is first time loading. use data
      let data_bottom = room_data.data_bottom;
      let data_top = room_data.data_top;
      room_bottom = [];
      room_top = [];
      for (data_row of data_bottom.split("|")) {
        let row = [];
        for (character of data_row.split(""))
          row.push(arch_bottom[character]);
        room_bottom.push(row);
      }
      for (data_row of data_top.split("|")) {
        let row = [];
        for (character of data_row.split(""))
          row.push(arch_top[character]);
        room_top.push(row);
      }
      room_data.room_bottom = room_bottom;
      room_data.room_top = room_top;
    }
    height = room_bottom.length;
    width = room_bottom[0].length;
    if (coming_from == "bottom") for (let x = 0; x < width; x++) if (room_bottom[height-1][x].exit) room_top[height-2][x] = arch_top["~"];
    if (coming_from == "top") for (let x = 0; x < width; x++) if (room_bottom[0][x].exit) room_top[1][x] = arch_top["~"];
    if (coming_from == "left") for (let y = 0; y < height; y++) if (room_bottom[y][0].exit) room_top[y][1] = arch_top["~"];
    if (coming_from == "right") for (let y = 0; y < height; y++) if (room_bottom[y][width-1].exit) room_top[y][width-2] = arch_top["~"];
    //other level data
    loaded_room_label = {label: label, coming_from: coming_from};
    active_exits = {
      right: room_data.exit_left,
      left: room_data.exit_right,
      top: room_data.exit_bottom,
      bottom: room_data.exit_top,
    }
    while (display.firstChild) display.firstChild.remove();
    //make table with images, bottom and top layers
    room_bottom_elements = [];
    room_top_elements = [];
    for (let y = 0; y < height; y++) {
      let tr = document.createElement("tr");
      room_bottom_elements[y] = [];
      room_top_elements[y] = [];
      for (let x = 0; x < width; x++) {
        let td = document.createElement("td");
        tr.appendChild(td);
        room_bottom_elements[y][x] = td;
        visual_update_bottom(y, x);
        let img = document.createElement("img");
        td.appendChild(img);
        room_top_elements[y][x] = img;
        visual_update_top(y, x);
      }
      display.appendChild(tr);
    }
    player_input(0, 0, true);
    sfx("room_up");
    setTimeout(function(){
      input_disabled = false;
    }, 1000);
  }
  
  function visual_update_bottom(y, x) {
    room_bottom_elements[y][x].setAttribute("background", room_bottom[y][x].img);
  }
  function visual_update_top(y, x) {
    let old_src = room_top_elements[y][x].getAttribute("src");
    if (old_src != room_top[y][x].img) {
      room_top_elements[y][x].setAttribute("src", room_top[y][x].img);
      let y_off = Math.random()*0;
      let x_off = Math.random()*0;
      room_top_elements[y][x].style.transform = "translate("+x_off+"px, "+y_off+"px)";
    }
  }
  
  function room_transition(label, coming_from = "left") { //actually call this to change room. open_room is called here
    sfx("room_down");
    for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) if (room_top[y][x].player) room_top[y][x] = arch_top["."]; //delete all players before saving
    for (td of display.querySelectorAll("td")) {
      td.style.animation = "1s td_exit";
    }
    setTimeout(function(){
      for (td of display.querySelectorAll("td")) {
        td.style.opacity = "0";
      }
    }, 900);
    setTimeout(function(){
      open_room(label, coming_from);
    }, 1000);
  }
  
  function reset_room() {
    if (crystal_shard_collected[loaded_room_label.label]) setTimeout(crystal_shard_unfanfare, 1000);
    delete all_rooms[loaded_room_label.label].room_bottom;
    delete all_rooms[loaded_room_label.label].room_top;
    room_transition(loaded_room_label.label, loaded_room_label.coming_from);
  }
  
  document.onkeydown = function(event) {
    let [y, x] = [-1, -1];
    if (input_disabled) return;
    switch (event.keyCode) {
      case 65: case 37:
        [y, x] = [0, -1];
        break;
      case 68: case 39:
        [y, x] = [0, 1];
        break;
      case 40: case 83:
        [y, x] = [1, 0];
        break;
      case 87: case 38:
        [y, x] = [-1, 0];
        break;
      case 32:
        [y, x] = [0, 0];
        break;
      case 82:
        reset_room();
        return;
    }
    if (x == -1 && y == -1) return;
    if (event.shiftKey) [y, x] = [y*2, x*2];
    player_input(y, x);
  }
  
  function arch_bottom_empty() {return {
    img: "art/empty.png"
  };}
  
  let arch_bottom = {
    //nothing's there
    ".": {img: "art/empty.png"},
    ",": {img: "art/ground0.png"},
    "i": {img: "art/ice.png", slippery: true},
    "w": {img: "art/conwayflooralive.png"},
    "s": {img: "art/conwayfloordead.png"},
    "M": {img: "art/dangerousfloor.png", deadly: true},
    "m": {img: "art/becomedangerousfloor.png", becomes: "M"},
    //goals
    "1": {img: "art/goal0.png", goal: 1},
    "2": {img: "art/goal1.png", goal: 2},
    "3": {img: "art/goal2.png", goal: 3},
    //boxdoor
    "!": {img: "art/boxdoor0closed.png", boxdoor: 1},
    "@": {img: "art/boxdoor1closed.png", boxdoor: 2},
    "#": {img: "art/boxdoor2closed.png", boxdoor: 3},
    ")": {img: "art/boxdoor0open.png", boxdoor: 1, invert: true},
    "(": {img: "art/boxdoor1open.png", boxdoor: 2, invert: true},
    "&": {img: "art/boxdoor2open.png", boxdoor: 3, invert: true},
    //exit
    "*": {img: "art/exit.png", exit: true},
    //stops!
    "[": {img: "art/riveredgeleft.png", stop: true},
    "]": {img: "art/riveredgeright.png", stop: true},
    "{": {img: "art/riveredgetop.png", stop: true},
    "}": {img: "art/riveredgebottom.png", stop: true},
    "=": {img: "art/riverfull.png", stop: true},
    "+": {img: "art/rivercornertopleft.png", stop: true},
    "-": {img: "art/rivercornertopright.png", stop: true},
    "_": {img: "art/rivercornerbottomleft.png", stop: true},
    ";": {img: "art/rivercornerbottomright.png", stop: true},
    "Q": {img: "art/walltopleft.png", stop: true},
    "W": {img: "art/walltop.png", stop: true},
    "E": {img: "art/walltopright.png", stop: true},
    "A": {img: "art/wallleft.png", stop: true},
    "S": {img: "art/wallinner.png", stop: true},
    "D": {img: "art/wallright.png", stop: true},
    "Z": {img: "art/wallbottomleft.png", stop: true},
    "X": {img: "art/wallbottom.png", stop: true},
    "C": {img: "art/wallbottomright.png", stop: true},
    "q": {img: "art/wallinnertopleft.png", stop: true},
    "e": {img: "art/wallinnertopright.png", stop: true},
    "z": {img: "art/wallinnerbottomleft.png", stop: true},
    "c": {img: "art/wallinnerbottomright.png", stop: true},
  };
  
  let arch_top = {
    //nothing's there
    ".": {img: "art/empty.png"},
    //something immovable is there
    "[": {img: "art/tree0.png", stop: true},
    "]": {img: "art/tree1.png", stop: true},
    "{": {img: "art/tree2.png", stop: true},
    "`": {img: "art/duckie.png", stop: true},
    //boxen
    "1": {img: "art/box0.png", box: 1},
    "2": {img: "art/box1.png", box: 2},
    "3": {img: "art/box2.png", box: 3, stop: true},
    //people
    "~": {img: "art/player.png", player: true, stop: true},
    "?": {img: "art/duckie.png", wanderer: true, stop: true},
    //uhhh other
    "$": {img: "art/crystalshard.png", collectable: true},
  };
  let box_data_to_weight = {"1":1,"2":0.000000001,"3":1};
  let box_data_pushing = [1, 2, 3];
  let box_data_pulling = [3];
  let box_satisfied = {"1":true,"2":true,"3":true};
  
  function player_input(input_dy, input_dx, only_do_static_checks = false) {
    if (input_disabled && !only_do_static_checks) return;
    //conway
    if (!only_do_static_checks) {
      //get before state
      let conway_before = [];
      for (let y = 0; y < height; y++) {
        conway_before[y] = [];
        for (let x = 0; x < width; x++) {
          conway_before[y][x] = room_bottom[y][x] == arch_bottom["w"];
        }
      }
      //do process
      let conway_after = [];
      for (let y = 0; y < height; y++) {
        conway_after[y] = [];
        for (let x = 0; x < width; x++) {
          if (room_bottom[y][x] != arch_bottom["w"] && room_bottom[y][x] != arch_bottom["s"]) continue; //skip if this spot cant be conwayed
          let alive_neighbors = 0;
          let last_alive_neighbor = null
          for (let neighbor_y = Math.max(0, y-1); neighbor_y <= Math.min(height-1, y+1); neighbor_y++) {
            for (let neighbor_x = Math.max(0, x-1); neighbor_x <= Math.min(width-1, x+1); neighbor_x++) {
              if (neighbor_x == x && neighbor_y == y) continue;
              if (conway_before[neighbor_y][neighbor_x]) {
                alive_neighbors++;
                last_alive_neighbor = room_bottom[neighbor_y][neighbor_x];
              }
            }
          }
          if (conway_before[y][x] ? (alive_neighbors==3 || alive_neighbors==2) : (alive_neighbors==3)) {
            //y,x should be alive
            room_bottom[y][x] = arch_bottom["w"];
            visual_update_bottom(y, x);
          } else {
            //y,x should be dead
            room_bottom[y][x] = arch_bottom["s"];
            visual_update_bottom(y, x);
          }
        }
      }
    }
    //move the players and wanderers
    if (!only_do_static_checks) for ([creature, [dy, dx]] of [["player", [input_dy, input_dx]], ["wanderer", [[1,0],[-1,0],[0,1],[0,-1]][Math.floor(Math.random()*4)]]]) { //for each pass of this movement code
      let [y_start, y_end, y_step] = dy < 0 ? [0, height - 1, 1] : [height - 1, 0, -1];
      let [x_start, x_end, x_step] = dx < 0 ? [0, width - 1, 1] : [width - 1, 0, -1];
      for (let y = y_start; y != y_end + y_step; y += y_step) {
        for (let x = x_start; x != x_end + x_step; x += x_step) {
          if (!room_top[y][x][creature]) continue;
          let new_y = y + dy;
          let new_x = x + dx;
          if (space_blocked_but_allowing_boxes(new_y, new_x)) continue;
          //we are walking into walkable, box, or collectable
          //do player motion
          if (box_data_pushing.includes(room_top[new_y][new_x].box)) { //if walking into box
            //at present, x,y=player, new=first box, super=final box
            let total_box_weight = box_data_to_weight[room_top[new_y][new_x].box]; //the weights from boxes bein moved
            if (dy < -1) dy = -1; if (dy > 1) dy = 1; if (dx < -1) dx = -1; if (dx > 1) dx = 1;
            let super_y = new_y + dy;
            let super_x = new_x + dx;
            if (space_blocked_but_allowing_boxes(super_y, super_x)) continue;
            while (room_top[super_y][super_x].box && !space_blocked_but_allowing_boxes(super_y+dy, super_x+dx)) {
              total_box_weight += box_data_to_weight[room_top[super_y][super_x].box];
              super_y += dy;
              super_x += dx;
            }
            if (total_box_weight > 1) continue;
            if (room_top[super_y][super_x].box) continue; //try to push 2+ boxes but super space blocked
            room_top[super_y][super_x] = room_top[new_y][new_x];
            room_top[new_y][new_x] = room_top[y][x];
            room_top[y][x] = arch_top["."];
            visual_update_top(super_y, super_x);
            visual_update_top(new_y, new_x);
            visual_update_top(y, x);
            sfx("pushbox");
          } else { //validly walking into something else. in theory a nothing top or a collectable
            //while slipping on ice (or the beyond is too much) lets slip and slide
            while (room_bottom[new_y][new_x].slippery && !space_blocked(new_y+dy, new_x+dx)) [new_y, new_x] = [new_y + dy, new_x + dx];
            if (room_top[new_y][new_x].collectable) crystal_shard_fanfare();
            room_top[new_y][new_x] = room_top[y][x];
            room_top[y][x] = arch_top["."];
            visual_update_top(new_y, new_x);
            visual_update_top(y, x);
          }
          //check if we're pulling
          if (!oob(y-dy,x-dx) && box_data_pulling.includes(room_top[y-dy][x-dx].box)) {
            room_top[y][x] = room_top[y-dy][x-dx];
            room_top[y-dy][x-dx] = arch_top["."];
            visual_update_top(y-dy, x-dx);
            visual_update_top(y, x);
            sfx("pushbox");
          }
          //affect floor behind us
          if (room_bottom[y][x].becomes) {
            room_bottom[y][x] = arch_bottom[room_bottom[y][x].becomes];
            visual_update_bottom(y, x);
          }
          //check for death
          if (room_bottom[new_y][new_x].deadly) {
            reset_room();
          }
        }
      }
    }
    //do box checks
    box_satisfied = {"1":true,"2":true,"3":true};
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        if (room_bottom[y][x].goal && room_bottom[y][x].goal != room_top[y][x].box) {
          box_satisfied[room_bottom[y][x].goal] = false;
        }
      }
    }
    //non inverted box doors
    arch_bottom["!"].stop = !box_satisfied["1"];
    arch_bottom["@"].stop = !box_satisfied["2"];
    arch_bottom["#"].stop = !box_satisfied["3"];
    arch_bottom["!"].img = !box_satisfied["1"] ? "art/boxdoor0closed.png" : "art/boxdoor0open.png";
    arch_bottom["@"].img = !box_satisfied["2"] ? "art/boxdoor1closed.png" : "art/boxdoor1open.png";
    arch_bottom["#"].img = !box_satisfied["3"] ? "art/boxdoor2closed.png" : "art/boxdoor2open.png";
    //inverted box doors
    arch_bottom[")"].stop = box_satisfied["1"];
    arch_bottom["("].stop = box_satisfied["2"];
    arch_bottom["&"].stop = box_satisfied["3"];
    arch_bottom[")"].img = box_satisfied["1"] ? "art/boxdoor0closed.png" : "art/boxdoor0open.png";
    arch_bottom["("].img = box_satisfied["2"] ? "art/boxdoor1closed.png" : "art/boxdoor1open.png";
    arch_bottom["&"].img = box_satisfied["3"] ? "art/boxdoor2closed.png" : "art/boxdoor2open.png";
    for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) if (room_bottom[y][x].boxdoor) visual_update_bottom(y, x);
    let coming_from = {
      "0": "left",
      "-2": "bottom",
      "3": "right",
      "2": "top"
    }[Math.round(Math.atan2(input_dy, input_dx))];
    if (Math.abs(input_dx)+Math.abs(input_dy)==0) coming_from = "static";
    if (!only_do_static_checks) sfx(coming_from);
    //check if on exit
    exit_check:
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        if (!room_bottom[y][x].exit) continue;
        if (!room_top[y][x].player) continue;
        input_disabled = true;
        let destination = active_exits[coming_from];
        room_transition(destination, coming_from);
        break exit_check;
      }
    }
  }
  
  function xor(a, b) {if (a && b) return false; if (!a && !b) return false; return true;}
  
  //if bottom is stop, or if top is stop, or oob
  function space_blocked(y, x) {
    if (oob(y, x)) return true;
    if (room_top[y][x].collectable) return false;
    if (room_bottom[y][x].stop || room_top[y][x].stop || room_top[y][x].box) return true;
    return false;
  }
  function space_blocked_but_allowing_boxes(y, x) {
    if (oob(y, x)) return true;
    if (room_top[y][x].collectable) return false;
    if (room_bottom[y][x].stop || room_top[y][x].stop) return true;
    return false;
  }
  function oob(y, x) {
    if (y < 0 || y >= height || x < 0 || x >= width) return true;
    return false;
  }
  
  //read pre into all_rooms
  let currently_making_room = null;
  for (line of document.querySelector("#all_level_info").innerText.trim().split("\n")) {
    line = line.trim();
    if (!line) continue;
    if (line.startsWith("@")) {
      currently_making_room = line.substring(1).trim();
      all_rooms[currently_making_room] = {};
    } else {
      all_rooms[currently_making_room][line.substring(0, line.indexOf(":")).trim()] = line.substring(line.indexOf(":")+1).trim();
    }
  }
  
  //crystal shards
  for (label of Object.keys(all_rooms)) if (all_rooms[label].data_top.includes("$")) {
    let img = document.createElement("img");
    img.setAttribute("label", label);
    img.setAttribute("collected", "false");
    img.setAttribute("src", "art/crystalshardoutline.png");
    document.querySelector("#crystal_shards").appendChild(img);
  }
  function crystal_shard_fanfare() {
    crystal_shard_collected[loaded_room_label.label] = true;
    let img = document.querySelector("#crystal_shards img[label=\""+loaded_room_label.label+"\"]");
    img.setAttribute("collected", "true");
    img.setAttribute("src", "art/crystalshard.png");
  }
  function crystal_shard_unfanfare() {
    delete crystal_shard_collected[loaded_room_label.label];
    let img = document.querySelector("#crystal_shards img[label=\""+loaded_room_label.label+"\"]");
    img.setAttribute("collected", "false");
    img.setAttribute("src", "art/crystalshardoutline.png");
  }
  
  function start_game() {
    sfx("room_down");
    document.querySelector("h1").style.animation = "1s title_exit";
    document.querySelector("h1").style.cursor = "default";
    setTimeout(function() {
      document.querySelector("h1").style.opacity = "0";
    },900);
    setTimeout(function() {
      document.querySelector("h1").remove();
      open_room('origin', 'left');
      //debug: make all room shortcuts
      if (false) for (label of Object.keys(all_rooms)) {
        let button = document.createElement("button");
        button.setAttribute("class", "shortcut")
        button.innerText = label;
        button.setAttribute("onclick", "room_transition('"+label+"')");
        document.body.appendChild(button);
      }
    }, 1000);
    start_game = function() {}
  }
  
  function sfx(aud) {
    //coming from direction: left top bottom right static
    //load unload: room_up room_down
    let a = new Audio("sound/"+{
      "left": "goright",
      "top": "godown",
      "bottom": "goup",
      "right": "goleft",
      "static": "staystill",
      "room_up": "magic",
      "room_down": "rumble",
      "pushbox": "rumble",
      "left": "goup",
      "top": "goup",
      "bottom": "goup",
      "right": "goup",
      "static": "staystill",
      "room_up": "magic",
      "room_down": "rumble",
      "pushbox": "godown"
    }[aud]+".mp3");
    a.volume = 0.5;
    a.play();
  }
  </script>
</body>
</html>